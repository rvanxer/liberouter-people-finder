/*
    Liberouter People Finder
    Copyright (C) 2021 Teemu Kärkkäinen

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License version 2 as
    published by the Free Software Foundation.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc.,
    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */
package com.spacetimenetworks.android.peoplefinder;

import android.app.Service;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.ServiceConnection;
import android.os.Binder;
import android.os.IBinder;
import android.util.Log;

import com.spacetimenetworks.android.peoplefinder.database.DataModel;
import com.spacetimenetworks.android.peoplefinder.database.DatabaseController;

import fi.tkk.netlab.dtn.scampi.applib.ApiException;
import fi.tkk.netlab.dtn.scampi.applib.AppLib;
import fi.tkk.netlab.dtn.scampi.applib.AppLibLifecycleListener;
import fi.tkk.netlab.dtn.scampi.applib.MessageReceivedCallback;
import fi.tkk.netlab.dtn.scampi.applib.SCAMPIMessage;
import fi.tkk.netlab.net.Util;

import java.io.ByteArrayOutputStream;
import java.io.Closeable;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.util.Collection;
import java.util.LinkedList;
import java.util.Map;
import java.util.Random;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

/**
 * <p> Service that handles communicating the SCAMPI router. Tries to connect to
 * a local router using the API protocol. Keeps retrying until successful if the
 * router is not running. </p> <p/> <p> Connects to {@link DatabaseController}
 * to insert received records and to send unpublished records. </p> <p/> <p>
 * There is no public API for the service, it works autonomously bridging the
 * application database and SCAMPI router. However, the Intent starting this
 * service must include {@link #INTENT_EXTRA_PIC_DIR_PATH} extra containing a
 * filesystem path as a String where received photos will be written to. </p>
 *
 * @author teemuk
 */
public class AppLibService
extends Service
implements DatabaseController.OnInsertedPerson,
           DatabaseController.OnInsertedNote,
           AppLibLifecycleListener, MessageReceivedCallback {
  // TODO:
  // - Synchronize the db instance variable

  //==========================================================================//
  // Constants
  //==========================================================================//
  /** SCAMPI pub/sub service name ({@value}). */
  public static final String PEOPLE_FINDER_SERVICE
      = "PeopleFinder";
  /** Log tag for messages generated by this class ({@value}). */
  public static final String TAG
      = AppLibService.class.getSimpleName();
  /** Default lifetime for posted messages in seconds ({@value}). */
  public static final long MSG_LIFETIME
      = 60 * 60 * 24 * 30;
  // 30 days
  /**
   * Intent extra containing a filesystem path where received photos are
   * written
   * to.
   */
  public static final String INTENT_EXTRA_PIC_DIR_PATH = "picDirPath";
  /** Time to wait between trying to connect AppLib (milliseconds). */
  public static final long RECONNECT_PERIOD = 8000;
  //==========================================================================//


  //==========================================================================//
  // Globals
  //==========================================================================//
  public static boolean isRunning;
  //==========================================================================//


  //==========================================================================//
  // Definitions of the SCAMPIMessage fields
  //==========================================================================//
  /**
   * Message field that contains the serialized records for a person as a
   * {@link
   * DataModel.SerializablePerson}.
   */
  public static final String MSG_RECORDS_FIELD = "records";
  /**
   * Message field that contains a photo for the person record. May not exists
   * if no photo is attached to the record.
   */
  public static final String MSG_PHOTO_FIELD = "photo";
  //==========================================================================//


  //==========================================================================//
  // Instance vars
  //==========================================================================//
  /** Flag indicating if {@link #onStartCommand} has been called. */
  private volatile boolean hasStarted;
  /** Filesystem path for storing photos. */
  private volatile File picDir;
  /** Binder for activities */
  private final IBinder binder = new AppLibService.AppLibBinder();
  /** Database where incoming messages are to be stored */
  private volatile DatabaseController db;
  /** AppLib connection to the router */
  private volatile AppLib appLib;
  /** Service connection to the database */
  private ServiceConnection databaseConnection;
  private final Random RNG
      = new Random();
  /**
   * Holds messages received from the AppLib before the database controller has
   * connected.
   */
  private final Collection<SCAMPIMessage> preconnectBuffer
      = new LinkedList<>();
  /** Task executor for connecting AppLib. */
  private ScheduledExecutorService scheduledExecutor;
  //==========================================================================//


  //==========================================================================//
  // Lifecycle
  //==========================================================================//
  @Override
  public IBinder onBind( Intent intent ) {
    Log.d( TAG, "onBind()" );

    return this.binder;
  }

  @Override
  public void onCreate() {
    super.onCreate();

    this.scheduledExecutor = Executors.newSingleThreadScheduledExecutor();

    // Create applib
    this.appLib = this.getAppLib();
    this.appLib.start();
    // Connect from a worker thread or Android complains about networking in
    // main thread.
    this.scheduleConnect( 0, TimeUnit.MILLISECONDS );

    // Bind to the database
    this.doBindDatabaseService();

    AppLibService.isRunning = true;

    Log.d( TAG, "onCreate()" );
  }

  @Override
  public void onDestroy() {
    super.onDestroy();

    this.scheduledExecutor.shutdownNow();

    // Unbind from the database
    this.doUnbindDatabaseService();

    this.appLib.stop();

    this.hasStarted = false;
    AppLibService.isRunning = false;

    Log.d( TAG, "onDestroy()" );
  }

  @Override
  public void onRebind( Intent intent ) {
    super.onRebind( intent );

    Log.d( TAG, "onRebind()" );
  }

  @Override
  public int onStartCommand( Intent intent, int flags, int startId ) {
    super.onStartCommand( intent, flags, startId );
    Log.d( TAG, "onStartCommand()" );

    // This might be called multiple times, execute only once.
    // XXX: Does android create another instance when restarting a destroyed Service?
    if ( this.hasStarted ) {
      Log.d( TAG, "Duplicate call to onStartCommand()" );
      return START_REDELIVER_INTENT;
    } else {
      this.hasStarted = true;
    }

    // Grab the path to pics dir
    // Get parameters passed in the intent
    // XXX: The following line causes NPE in some cases
    String picPath = intent.getStringExtra( INTENT_EXTRA_PIC_DIR_PATH );
    if ( picPath != null && picPath.length() > 0 ) {
      this.picDir = new File( picPath );
      if ( !this.picDir.exists() ) {
        if ( !this.picDir.mkdirs() ) {
          Log.d( TAG, "Failed to create directory for pics '" +
                      this.picDir.getAbsolutePath() + "'." );
          this.picDir = null;
        }
      } else if ( !this.picDir.isDirectory() ) {
        Log.d( TAG, "Picture directory '" + this.picDir.getAbsolutePath()
                    + "' exists and is not a directory." );
        this.picDir = null;
      }
    }

    return START_REDELIVER_INTENT;
  }
  //==========================================================================//


  //==========================================================================//
  // Private - Incoming message handling
  //==========================================================================//
  private void handleIncomingMessage( SCAMPIMessage msg )
  throws Exception {
    Log.d( TAG, "Handling incoming message." );

    // Precondition check
    boolean hasRecords = msg.hasBinary( MSG_RECORDS_FIELD );
    if ( !hasRecords ) {
      throw new IOException( "Invalid message, no records found." );
    }

    // If database is not connected, add the message to pre-connect buffer
    if ( this.db == null ) {
      synchronized ( this.preconnectBuffer ) {
        if ( this.db == null ) { // Need to check again,
          // since it might have been set while
          // blocking in synchronized
          this.preconnectBuffer.add( msg );
          return;
        }
      }
    }

    // Read the person record
    DataModel.SerializablePerson personRecord =
        this.readPerson( msg );
    Log.d( TAG, "Read person: " + personRecord.person.metadata.recordID +
                " (" + personRecord.person.identity.name.fullName +
                ") with " + personRecord.notes.size() + " note(s)." );

    // Get the message picture
    // TODO: Picture handling
    //File picFile = msg.getAsFile( MSG_PHOTO_FIELD );

    // Insert into the database
    this.insertIntoDatabase( personRecord, null );
  }

  private DataModel.SerializablePerson readPerson(
      SCAMPIMessage msg )
  throws IOException, ApiException {
    // Precondition check
    if ( !msg.hasBinary( MSG_RECORDS_FIELD ) ) {
      throw new IOException( "Invalid message, no '"
                              + MSG_RECORDS_FIELD + "' field found." );
    }

    InputStream in = null;
    ObjectInputStream oin = null;
    try {
      // Get the correct message field
      in = msg.getBinary( MSG_RECORDS_FIELD );

      // Read the record from the stream
      oin = new ObjectInputStream( in );
      Object o = oin.readObject();
      if ( !( o instanceof DataModel.SerializablePerson ) ) {
        Log.e( TAG, "Couldn't deserialize message. Incorrect class type." );
        throw new IOException( "Unknown record class found." );
      }
      return ( DataModel.SerializablePerson ) ( o );
    } catch ( ClassNotFoundException e ) {
      Log.d( TAG, "Couldn't deserialize message. Class not found (" +
                  e.getMessage() + ")." );
      throw new IOException( e );
    } finally {
      if ( oin != null ) {
        try {
          oin.close();
        } catch ( IOException e ) {
        }
      } else if ( in != null ) {
        try {
          in.close();
        } catch ( IOException e ) {
        }
      }
    }
  }

  private void insertIntoDatabase(
      DataModel.SerializablePerson record, File photo ) {
    // First copy the photo to correct place if necessary
    String photoPath = null;
    if ( photo != null && photo.isFile() ) {
      File to = new File( this.picDir, record.person.metadata.recordID );
      try {
        Util.copyFile( photo, to );
        photoPath = to.getAbsolutePath();
      } catch ( IOException e ) {
        Log.e( TAG, "Failed to copy a received person picture to '" +
                    to.getAbsolutePath() + "' (" + e.getMessage() + ")." );
      }
    }

    // Then create insertion tasks in the database

    // Insert person
    DataModel.LocalPerson row
        = new DataModel.LocalPerson( record.person, photoPath,
        true /* routed */ );
    this.db.insertPerson( row, null ); // Don't care about callback here

    // Insert all notes
    for ( DataModel.Note note : record.notes ) {
      DataModel.LocalNote noteRow =
          new DataModel.LocalNote( note, null, true );
      this.db.insertNote( noteRow, null ); // Don't care about callback here
    }
  }
  //==========================================================================//


  //==========================================================================//
  // AppLib handling
  //==========================================================================//
  private AppLib getAppLib() {
    AppLib applib = new AppLib();

    // Lifecycle listener
    applib.addLifecycleListener( this );

    // Setup subscription to the service
    applib.addMessageReceivedCallback( PEOPLE_FINDER_SERVICE, this );
    try {
      applib.subscribe( PEOPLE_FINDER_SERVICE );
    } catch ( InterruptedException e ) {
      Log.d( TAG, "Subscribing failed (" + e.getMessage() + ")" );
    }

    return applib;
  }

  //--------------------------------------------------------------------------//
  // MessageReceivedCallback
  //--------------------------------------------------------------------------//
  @Override
  public void messageReceived( SCAMPIMessage scampiMessage, String service ) {
    Log.d( TAG, "AppLib message received." );

    if ( PEOPLE_FINDER_SERVICE.equals( service ) ) {
      try {
        this.handleIncomingMessage( scampiMessage );
      } catch ( Exception e ) {
        Log.e( TAG, "Invalid SCAMPI message (" + e.getMessage() + ").", e );
      }
    } else {
      Log.d( TAG, "Received message published to an incorrect service '"
                  + service + "'." );
    }
  }

  //--------------------------------------------------------------------------//
  // LifecycleListener
  //--------------------------------------------------------------------------//
  @Override
  public void onConnected( String scampiId ) {
    Log.d( TAG, "AppLib connected: " + scampiId );

    // Publish un-routed messages if database is already connected
    if ( this.db != null ) {
      this.triggerRouting();
    }
  }

  @Override
  public void onDisconnected() {
    Log.d( TAG, "AppLib disconnected" );
    this.scheduleConnect( RECONNECT_PERIOD, TimeUnit.MILLISECONDS );
  }

  @Override
  public void onConnectFailed() {
    Log.d( TAG, "AppLib connect failed" );
    this.scheduleConnect( RECONNECT_PERIOD, TimeUnit.MILLISECONDS );
  }

  @Override
  public void onStopped() {
    Log.d( TAG, "AppLib stopped" );
    // Terminal state
  }
  //==========================================================================//


  //==========================================================================//
  // Private - Building a SCAMPI message
  //==========================================================================//
  private void publishRecords(
      Collection<DataModel.SerializablePerson> records,
      Map<String, String> picPaths ) {
    // Publish each message
    for ( DataModel.SerializablePerson record : records ) {
      // Get pic path if one exists
      String picPath = null;
      if ( picPaths.containsKey( record.person.metadata.recordID ) ) {
        picPath = picPaths.get( record.person.metadata.recordID );
      }

      // Create and publish SCAMPI message
      try {
        SCAMPIMessage msg = this.createMessage( record, picPath );
        this.appLib.publish( msg, PEOPLE_FINDER_SERVICE );
      } catch ( Exception e ) {
        Log.d( TAG, "Failed to publish SCAMPI message (" +
                    e.getMessage() + ")." );
        continue;
      }

      // Set the routed status of the record
      this.db.setRouted( record );

      Log.d( TAG, "Published record for person: " +
                  record.person.metadata.recordID + " (" +
                  record.person.identity.name.fullName + ")" );
    }
  }

  /**
   * Creates a {@code SCAMPIMessage} for the records.
   *
   * @param records
   *     records to send
   * @param picPath
   *     path to a picture to attach or {@code null}.
   *
   * @return {@link SCAMPIMessage} containing the given records
   */
  private SCAMPIMessage createMessage(
      DataModel.SerializablePerson records, String picPath )
  throws IOException {
    // Use the person record ID as AppTag. This causes the router to
    // replace older version of the same person's message with the new one.
    SCAMPIMessage msg = new SCAMPIMessage( records.person.metadata.recordID );
    msg.setLifetime( MSG_LIFETIME );

    // Serialize the records
    ByteArrayOutputStream bout = null;
    ObjectOutputStream out = null;
    byte[] serializedRecords;
    try {
      bout = new ByteArrayOutputStream();
      out = new ObjectOutputStream( bout );
      out.writeObject( records );
      serializedRecords = bout.toByteArray();
    } finally {
      close( out );
      close( bout );
    }

    // Set the serialized records
    msg.putBinary( MSG_RECORDS_FIELD, serializedRecords );

    // Set the picture if one exists
    if ( picPath != null && picPath.length() > 0 ) {
      File pic = new File( picPath );
      if ( pic.isFile() ) {
        msg.putBinary( MSG_PHOTO_FIELD, pic );
      } else {
        Log.d( TAG, "Provided picture '" + pic.getAbsolutePath() + "' " +
                    "does not exist or is not a file." );
      }
    }

    return msg;
  }
  //==========================================================================//


  //==========================================================================//
  // Database update listeners
  //==========================================================================//
  @Override
  public void onInserted( long id, DataModel.LocalNote row ) {
    // Ignore records already seen by the router
    if ( row.routed ) return;

    // Trigger the routing of all unrouted messages
    this.triggerRouting();
  }

  @Override
  public void onInserted( long id, DataModel.LocalPerson row ) {
    // Ignore records already seen by the router
    if ( row.routed ) return;

    // Trigger the routing of all unrouted messages
    this.triggerRouting();
  }

  private void triggerRouting() {
    Log.d( TAG, "Routing triggered." );

    // Do nothing if AppLib is not connected.
    // When the AppLib does connect we will query the database for all
    // un-routed message and publish them in batch.
    if ( this.appLib == null ||
          this.appLib.getLifecycleState() != AppLib.State.CONNECTED ) {
      Log.d( TAG, "No connected AppLib instance, cannot route." );
      return;
    }

    // Query the database for all un-routed records and then publish them
    this.db.getAllUnrouted(
        new DatabaseController.GetAllUnroutedQueryFinished() {
          @Override
          public void queryFinished(
              Collection<DataModel.SerializablePerson> records,
              Map<String, String> picPaths ) {
            // TODO: Should probably not do this from the database thread
            Log.d( TAG, "Got " + records.size() + " un-routed records:" );

            publishRecords( records, picPaths );
          }
        }
    );

    Log.d( TAG, "triggerRouting() done" );
  }
  //==========================================================================//


  //==========================================================================//
  // Reconnect timer
  //==========================================================================//
  // Reconnect timer attempts to connect an AppLib instance to the router on
  // some fixed period. This allows the router process to be closed down
  // and brought up with the AppLibService connecting to it when it's
  // available.
  //------------------------------------------------------------------------//
  private void scheduleConnect( long delay, TimeUnit unit ) {
    Log.d( TAG, "Scheduling applib connect in: " + delay + " " + unit );
    this.scheduledExecutor.schedule( new ReconnectTask( this.appLib ),
        delay, unit );
  }

  private static class ReconnectTask
  implements Runnable {
    private final AppLib appLib;

    public ReconnectTask( AppLib appLib ) {
      this.appLib = appLib;
    }

    @Override
    public void run() {
      AppLib.State state = this.appLib.getLifecycleState();
      if ( state == AppLib.State.IDLE
           || state == AppLib.State.NEW ) {
        Log.d( TAG, "Trying to connect appLib" );
        this.appLib.connect();
      } else {
        Log.d( TAG, "Can't connect, lifecycle state: " + state );
      }
    }
  }
  //==========================================================================//


  //==========================================================================//
  // Binding to DatabaseController
  //------------------------------------------------------------------------//
  // The AppLib service binds to the database controller in order to insert
  // received messages and to publish newly generated messages.
  //==========================================================================//
  private void doBindDatabaseService() {
    this.databaseConnection = this.getServiceConnection();
    super.bindService( new Intent( this, DatabaseController.class ),
        this.databaseConnection, Context.BIND_AUTO_CREATE );
  }

  private void doUnbindDatabaseService() {
    super.unbindService( this.databaseConnection );
  }

  private ServiceConnection getServiceConnection() {
    return new ServiceConnection() {
      @Override
      public void onServiceConnected( ComponentName componentName,
                                      IBinder iBinder ) {
        Log.d( TAG, "Database connected" );

        if ( !( iBinder instanceof DatabaseController.DatabaseBinder ) ) {
          Log.e( TAG, "Wrong type of binder in onServiceConnected()" );
          return;
        }

        // Setup the database
        DatabaseController.DatabaseBinder binder =
            ( DatabaseController.DatabaseBinder ) iBinder;
        AppLibService.this.db = binder.getService();
        AppLibService.this.db
            .addOnInsertedNoteCallback( AppLibService.this );
        AppLibService.this.db
            .addOnInsertedPersonCallback( AppLibService.this );

        // Trigger routing of un-routed messages if the AppLib is connected
        if ( appLib != null
              && appLib.getLifecycleState() == AppLib.State.CONNECTED ) {
          triggerRouting();
        }
      }

      @Override
      public void onServiceDisconnected( ComponentName componentName ) {
        Log.d( TAG, "Database disconnected" );
        AppLibService.this.db = null;

        // Deactivate AppLib
                /*if ( appLib != null ) {
                    // This doesn't actually exist... oops
                    // appLib.unsubscribe( GUERRILLA_PICS_SERVICE );
                }*/
      }
    };
  }
  //==========================================================================//


  //==========================================================================//
  // Binder
  //==========================================================================//
  public class AppLibBinder
      extends Binder {
    AppLibService getService() {
      return AppLibService.this;
    }
  }
  //==========================================================================//


  //==========================================================================//
  // Private - utilities
  //==========================================================================//
  private static void close( final Closeable object ) {
    if ( object != null ) {
      try {
        object.close();
      } catch ( IOException e ) { /* Ignore, can't recover. */ }
    }
  }
  //==========================================================================//
}
